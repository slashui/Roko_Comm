用户购买课程后自动授权系统的需求规格说明
1. 业务目标 (Business Goal)
本需求旨在设计并实现一个自动化、无缝的课程授权系统。当用户通过 Stripe 成功支付购买课程后，系统应能根据用户的登录状态，准确地将其购买的课程与正确的用户账户绑定，确保用户可以立即或在完成必要的登录/注册步骤后，顺利访问所购内容。

2. 核心场景 (Core Scenarios)
系统必须能够优雅地处理以下三种用户场景：

场景A：用户已登录 - 用户在购买时已处于登录状态。

场景B：用户已注册但未登录 - 用户在购买时未登录，但使用的邮箱已在本系统中注册过账户。

场景C：用户未注册 - 用户首次购买，使用的邮箱在本系统中不存在。

3. 数据库结构变更 (Database Schema Changes)
为了支持上述所有场景，特别是未登录用户购买的“待认领”流程，我们需要对 Purchase 表进行以下调整。

变更对象: Purchase 表

字段名 (Field)	当前状态 (Current)	目标状态 (Target)	变更说明 (Reason)
userId	String (not null)	String? (nullable)	核心变更。 允许在用户未登录时创建购买记录，userId 暂时为空，等待用户后续登录或注册后进行关联。
customerEmail	(不存在)	String	新增字段。 用于存储Stripe返回的购买者邮箱。这是在userId为空时，我们唯一能用来识别和关联用户的凭证。
courseId (或productId)	text (not null)	String (Foreign Key)	建议变更。 建议将此字段明确命名为 courseId 并与 Course 表建立外键关联，以保证数据的完整性和一致性。
status	PaymentStatus	PaymentStatus (扩展)	建议扩展枚举值。 在原有的PENDING, COMPLETED 基础上，增加一个 PENDING_CLAIM (待认领)状态，使购买记录的状态更加清晰。

Export to Sheets
调整后的 Prisma Schema 示例 (schema.prisma):

Code snippet

model Purchase {
  id                String    @id @default(cuid())
  
  // --- 核心变更 ---
  userId            String?   // 改为可选，允许为 null
  customerEmail     String    // 新增字段，记录购买者邮箱
  
  courseId          String    // 建议与 Course 表关联
  stripeSessionId   String?   @unique
  stripePriceId     String
  amount            Float
  currency          String    @default("CNY")
  status            PaymentStatus @default(PENDING) // 可增加 PENDING_CLAIM
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  user              User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  course            Course    @relation(fields: [courseId], references: [id])
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  PENDING_CLAIM // 建议增加
}
4. 详细流程说明 (Detailed Process Flow)
阶段一：支付成功与重定向
用户在前端选择课程，点击购买，被重定向至 Stripe Checkout 支付页面。

用户完成支付。

Stripe 将用户重定向回你的网站的成功页面，URL中会附带一个 session_id，例如: /cn/checkout/success?session_id=cs_test_...。

阶段二：后端核心处理逻辑 (在API Route或Server Action中执行)
接收 Session ID: 前端成功页面将 URL 中的 session_id 发送到后端处理接口。

验证支付合法性 (安全):

必须执行: 后端使用 Stripe SDK 调用 stripe.checkout.sessions.retrieve(session_id)。

验证返回的 session 对象，确保 payment_status 为 paid。若验证失败或状态不符，则为非法请求，立即终止流程。

提取关键信息: 从验证后的 session 对象中提取：

Stripe 产品 ID (line_items.data[0].price.product)。

购买者邮箱 (customer_details.email)。

查找内部课程: 使用 Stripe 产品 ID，在 Course 表中通过 stripeId 字段查询到对应的内部 courseId。

判断用户登录状态: 检查当前请求是否存在有效的用户会话 (Session)。

阶段三：分场景处理
如果用户已登录 (场景A):

从会话中获取当前 userId。

在 Purchase 表中创建一条完整的购买记录，包含 userId, courseId, customerEmail 以及所有 Stripe 相关信息，status 设为 COMPLETED。

在 UserCourse 关联表中创建一条记录，将 userId 和 courseId 绑定。

向前端返回成功信息，告知课程已解锁。

如果用户未登录 (场景 B 和 C):

此时无法获取 userId。

在 Purchase 表中创建一条**“待认领”**的购买记录：

userId 字段设为 NULL。

customerEmail 字段存入从 Stripe 获取的邮箱。

courseId 及其他 Stripe 信息照常存入。

status 设为 PENDING_CLAIM。

向前端返回一个特定状态，告知购买已成功，但需要用户登录或注册来完成绑定。

阶段四：用户认领流程
前端引导:

前端收到“待认领”状态后，需要调用另一个后端接口，用 customerEmail 查询 User 表，判断该邮箱是否已注册。

如果邮箱已注册 (场景B): 前端页面显示：“购买成功！请登录以访问您的课程。” 并提供登录链接。

如果邮箱未注册 (场景C): 前端页面显示：“购买成功！请完成注册以访问您的课程。” 并显示注册表单（邮箱已预填且不可修改）。

后端认领逻辑 (登录或注册成功后触发):

触发时机: 在用户成功登录或成功注册的逻辑执行完毕后，必须立即触发一个“认领检查”函数。

检查操作:

获取当前登录/新注册用户的 id 和 email。

使用该 email 查询 Purchase 表，查找所有 customerEmail 匹配且 userId 为 NULL 的记录。

执行认领:

如果找到待认领的购买记录，遍历这些记录。

将每条记录的 userId 更新为当前用户的 id，并将 status 更新为 COMPLETED。

同时，在 UserCourse 表中为用户创建对应的课程关联。

完成: 认领流程结束，用户现在已经拥有了课程的访问权限。

5. 前端交互建议 (Frontend Interaction)
支付成功页面 (/payment/success): 应该是一个动态页面，根据后端返回的状态显示不同的信息。

状态 COMPLETED: "支付成功！您的课程已解锁，点击[我的课程]开始学习。"

状态 PENDING_CLAIM: "支付成功！请登录或注册来认领您的课程。"

登录/注册流程: 登录或注册成功后，应自动将用户重定向到“我的课程”页面或他们刚刚购买的课程详情页，提供流畅的体验。